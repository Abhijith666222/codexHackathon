`codex-rs/tui/src/state` is not currently writable from this environment (`read-only` sandbox), so I canâ€™t apply changes directly.  
Here is a drop-in file you can add under that scope.

`codex-rs/tui/src/state/mod.rs`
```rust
use std::cmp::Ordering;
use std::collections::HashSet;

const DEFAULT_TASK_PAGE_SIZE: usize = 25;

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub enum TaskLoadMode {
    #[default]
    Refresh,
    Append,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum TaskStatusFilter {
    All,
    Running,
    Completed,
    Failed,
    Canceled,
    Pending,
    Other(String),
}

impl Default for TaskStatusFilter {
    fn default() -> Self {
        Self::All
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TaskSortOrder {
    UpdatedAtDesc,
    UpdatedAtAsc,
    CreatedAtDesc,
    CreatedAtAsc,
    NameAsc,
    NameDesc,
}

impl Default for TaskSortOrder {
    fn default() -> Self {
        Self::UpdatedAtDesc
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct TaskFilterState {
    pub query: String,
    pub status: TaskStatusFilter,
    pub environment: Option<String>,
    pub owner: Option<String>,
    pub sort_order: TaskSortOrder,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TaskListItem {
    pub id: String,
    pub name: String,
    pub status: Option<String>,
    pub environment: Option<String>,
    pub owner: Option<String>,
    pub created_at: Option<i64>,
    pub updated_at: Option<i64>,
}

impl TaskListItem {
    fn matches_query(&self, lowered_query: &str) -> bool {
        if lowered_query.is_empty() {
            return true;
        }
        self.id.to_lowercase().contains(lowered_query)
            || self.name.to_lowercase().contains(lowered_query)
            || self
                .environment
                .as_ref()
                .is_some_and(|environment| environment.to_lowercase().contains(lowered_query))
            || self
                .status
                .as_ref()
                .is_some_and(|status| status.to_lowercase().contains(lowered_query))
    }

    fn matches_filters(&self, lowered_query: &str, filters: &TaskFilterState) -> bool {
        let status = self.status.as_deref().unwrap_or("");
        let status_matches = match &filters.status {
            TaskStatusFilter::All => true,
            TaskStatusFilter::Running => status.eq_ignore_ascii_case("running"),
            TaskStatusFilter::Completed => status.eq_ignore_ascii_case("completed"),
            TaskStatusFilter::Failed => status.eq_ignore_ascii_case("failed"),
            TaskStatusFilter::Canceled => status.eq_ignore_ascii_case("canceled"),
            TaskStatusFilter::Pending => status.eq_ignore_ascii_case("pending"),
            TaskStatusFilter::Other(expected) => status.eq_ignore_ascii_case(expected),
        };
        if !status_matches {
            return false;
        }

        let environment_matches = match filters.environment.as_deref() {
            Some(environment_filter) => self
                .environment
                .as_deref()
                .is_some_and(|environment| environment.eq_ignore_ascii_case(environment_filter)),
            None => true,
        };
        if !environment_matches {
            return false;
        }

        let owner_matches = match filters.owner.as_deref() {
            Some(owner_filter) => self
                .owner
                .as_deref()
                .is_some_and(|owner| owner.eq_ignore_ascii_case(owner_filter)),
            None => true,
        };
        if !owner_matches {
            return false;
        }

        self.matches_query(lowered_query)
    }
}

impl TaskSortOrder {
    fn compare(self, lhs: &TaskListItem, rhs: &TaskListItem) -> Ordering {
        let timestamp_cmp = match self {
            Self::UpdatedAtDesc => compare_optional_timestamp_desc(lhs.updated_at, rhs.updated_at),
            Self::UpdatedAtAsc => compare_optional_timestamp_asc(lhs.updated_at, rhs.updated_at),
            Self::CreatedAtDesc => compare_optional_timestamp_desc(lhs.created_at, rhs.created_at),
            Self::CreatedAtAsc => compare_optional_timestamp_asc(lhs.created_at, rhs.created_at),
            Self::NameAsc => lhs.name.to_lowercase().cmp(&rhs.name.to_lowercase()),
            Self::NameDesc => rhs.name.to_lowercase().cmp(&lhs.name.to_lowercase()),
        };
        timestamp_cmp.then_with(|| lhs.id.cmp(&rhs.id))
    }
}

fn compare_optional_timestamp_desc(lhs: Option<i64>, rhs: Option<i64>) -> Ordering {
    match (lhs, rhs) {
        (Some(lhs), Some(rhs)) => rhs.cmp(&lhs),
        (Some(_), None) => Ordering::Less,
        (None, Some(_)) => Ordering::Greater,
        (None, None) => Ordering::Equal,
    }
}

fn compare_optional_timestamp_asc(lhs: Option<i64>, rhs: Option<i64>) -> Ordering {
    compare_optional_timestamp_desc(rhs, lhs)
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TaskLoadRequest {
    pub request_id: u64,
    pub mode: TaskLoadMode,
    pub cursor: Option<String>,
    pub page_size: usize,
    pub filters: TaskFilterState,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TaskLoadResponse {
    pub items: Vec<TaskListItem>,
    pub next_cursor: Option<String>,
    pub has_more_hint: Option<bool>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct TaskLoadInFlight {
    request_id: u64,
    mode: TaskLoadMode,
    cursor: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct TaskLoadFailure {
    request_id: u64,
    message: String,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum TaskFetchState {
    Idle,
    Loading(TaskLoadInFlight),
    Failed(TaskLoadFailure),
}

impl TaskFetchState {
    pub fn is_loading(&self) -> bool {
        matches!(self, Self::Loading(_))
    }

    fn request_id(&self) -> Option<u64> {
        match self {
            Self::Loading(in_flight) => Some(in_flight.request_id),
            _ => None,
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct TaskSelectionState {
    pub visible_index: Option<usize>,
    pub task_id: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TaskPaginationState {
    pub page_size: usize,
    pub next_cursor: Option<String>,
    pub reached_end: bool,
    pub has_more_hint: bool,
}

impl Default for TaskPaginationState {
    fn default() -> Self {
        Self {
            page_size: DEFAULT_TASK_PAGE_SIZE,
            next_cursor: None,
            reached_end: false,
            has_more_hint: false,
        }
    }
}

#[derive(Clone, Debug)]
pub enum TaskAction {
    RefreshRequested,
    NextPageRequested,
    PageLoaded {
        request_id: u64,
        response: TaskLoadResponse,
    },
    PageLoadFailed {
        request_id: u64,
        error: String,
    },
    SetQuery(String),
    SetStatusFilter(TaskStatusFilter),
    SetEnvironmentFilter(Option<String>),
    SetOwnerFilter(Option<String>),
    SetSortOrder(TaskSortOrder),
    MoveSelection {
        delta: isize,
    },
    SetSelection(Option<usize>),
    ClearSelection,
    Reset,
}

#[derive(Clone, Debug)]
pub struct TaskScreenState {
    pub items: Vec<TaskListItem>,
    pub visible_task_ids: Vec<String>,
    pub filters: TaskFilterState,
    pub pagination: TaskPaginationState,
    pub fetch_state: TaskFetchState,
    pub selection: TaskSelectionState,
    pub needs_refetch: bool,
    pub error: Option<String>,
    request_id_counter: u64,
}

impl Default for TaskScreenState {
    fn default() -> Self {
        Self::new(DEFAULT_TASK_PAGE_SIZE)
    }
}

impl TaskScreenState {
    pub fn new(page_size: usize) -> Self {
        let page_size = page_size.max(1);
        Self {
            items: Vec::new(),
            visible_task_ids: Vec::new(),
            filters: TaskFilterState {
                page_size::(),
                ..Default::default()
            },
            pagination: TaskPaginationState {
                page_size,
                ..Default::default()
            },
            fetch_state: TaskFetchState::Idle,
            selection: TaskSelectionState::default(),
            needs_refetch: true,
            error: None,
            request_id_counter: 0,
        }
    }

    pub fn selected_task(&self) -> Option<&TaskListItem> {
        let index = self.selection.visible_index?;
        self.visible_task_ids
            .get(index)
            .and_then(|selected_id| self.items.iter().find(|item| &item.id == selected_id))
    }

    pub fn dispatch(&mut self, action: TaskAction) -> Option<TaskLoadRequest> {
        match action {
            TaskAction::RefreshRequested => self.start_load(TaskLoadMode::Refresh),
            TaskAction::NextPageRequested => self.start_load(TaskLoadMode::Append),
            TaskAction::PageLoaded {
                request_id,
                response,
            } => {
                let mode = self.current_load_mode(request_id)?;
                self.apply_loaded_page(mode, response);
                None
            }
            TaskAction::PageLoadFailed {
                request_id,
                error,
            } => {
                if self.current_load_mode(request_id).is_none() {
                    return None;
                }
                self.fetch_state = TaskFetchState::Failed(TaskLoadFailure { request_id, message: error.clone() });
                self.error = Some(error);
                None
            }
            TaskAction::SetQuery(query) => {
                if self.filters.query != query {
                    self.filters.query = query;
                    self.needs_refetch = true;
                    self.recompute_visible_ids();
                }
                None
            }
            TaskAction::SetStatusFilter(status) => {
                if self.filters.status != status {
                    self.filters.status = status;
                    self.needs_refetch = true;
                    self.recompute_visible_ids();
                }
                None
            }
            TaskAction::SetEnvironmentFilter(environment) => {
                if self.filters.environment != environment {
                    self.filters.environment = environment;
                    self.needs_refetch = true;
                    self.recompute_visible_ids();
                }
                None
            }
            TaskAction::SetOwnerFilter(owner) => {
                if self.filters.owner != owner {
                    self.filters.owner = owner;
                    self.needs_refetch = true;
                    self.recompute_visible_ids();
                }
                None
            }
            TaskAction::SetSortOrder(sort_order) => {
                if self.filters.sort_order != sort_order {
                    self.filters.sort_order = sort_order;
                    self.recompute_visible_ids();
                }
                None
            }
            TaskAction::MoveSelection { delta } => {
                if self.visible_task_ids.is_empty() {
                    self.selection = TaskSelectionState::default();
                    return None;
                }

                let max = (self.visible_task_ids.len() - 1) as isize;
                let current = self.selection.visible_index.unwrap_or(0) as isize;
                let next = (current + delta).clamp(0, max) as usize;

                self.selection.visible_index = Some(next);
                self.selection.task_id = Some(self.visible_task_ids[next].clone());
                None
            }
            TaskAction::SetSelection(index) => {
                if self.visible_task_ids.is_empty() {
                    self.selection = TaskSelectionState::default();
                    return None;
                }
                if let Some(index) = index {
                    let index = index.min(self.visible_task_ids.len() - 1);
                    self.selection.visible_index = Some(index);
                    self.selection.task_id = Some(self.visible_task_ids[index].clone());
                } else {
                    self.selection = TaskSelectionState::default();
                }
                None
            }
            TaskAction::ClearSelection => {
                self.selection = TaskSelectionState::default();
                None
            }
            TaskAction::Reset => {
                let page_size = self.pagination.page_size;
                *self = Self::new(page_size);
                None
            }
        }
    }

    fn current_load_mode(&mut self, request_id: u64) -> Option<TaskLoadMode> {
        match &self.fetch_state {
            TaskFetchState::Loading(in_flight) if in_flight.request_id == request_id => Some(in_flight.mode),
            _ => None,
        }
    }

    fn start_load(&mut self, mode: TaskLoadMode) -> Option<TaskLoadRequest> {
        if self.fetch_state.is_loading() {
            return None;
        }

        if matches!(mode, TaskLoadMode::Append) {
            if self.pagination.reached_end {
                return None;
            }
            if self.items.is_empty() {
                return None;
            }
        }

        let cursor = if matches!(mode, TaskLoadMode::Refresh) {
            None
        } else {
            self.pagination.next_cursor.clone()
        };

        let request_id = self.request_id_counter;
        self.request_id_counter = self.request_id_counter.saturating_add(1);

        self.fetch_state = TaskFetchState::Loading(TaskLoadInFlight {
            request_id,
            mode,
            cursor: cursor.clone(),
        });
        self.error = None;
        self.needs_refetch = false;

        Some(TaskLoadRequest {
            request_id,
            mode,
            cursor,
            page_size: self.pagination.page_size,
            filters: self.filters.clone(),
        })
    }

    fn apply_loaded_page(&mut self, mode: TaskLoadMode, response: TaskLoadResponse) {
        match mode {
            TaskLoadMode::Refresh => {
                self.items = response.items;
            }
            TaskLoadMode::Append => {
                let existing: HashSet<String> = self
                    .items
                    .iter()
                    .map(|task| task.id.clone())
                    .collect();
                let mut deduped = existing;
                for task in response.items {
                    if deduped.insert(task.id.clone()) {
                        self.items.push(task);
                    }
                }
            }
        }

        self.pagination.next_cursor = response.next_cursor;
        self.pagination.reached_end = self.pagination.next_cursor.is_none();
        self.pagination.has_more_hint = response.has_more_hint.unwrap_or(!self.pagination.reached_end);

        self.fetch_state = TaskFetchState::Idle;
        self.error = None;
        self.needs_refetch = false;

        self.recompute_visible_ids();
    }

    fn recompute_visible_ids(&mut self) {
        let lowered_query = self.filters.query.trim().to_lowercase();
        let mut visible_indices = (0..self.items.len()).collect::<Vec<_>>();
        visible_indices.retain(|index| self.items[*index].matches_filters(&lowered_query, &self.filters));
        visible_indices.sort_by(|&left, &right| {
            let left_item = &self.items[left];
            let right_item = &self.items[right];
            self.filters.sort_order.compare(left_item, right_item)
        });

        self.visible_task_ids = visible_indices
            .into_iter()
            .map(|index| self.items[index].id.clone())
            .collect();

        self.reconcile_selection();
    }

    fn reconcile_selection(&mut self) {
        if self.visible_task_ids.is_empty() {
            self.selection = TaskSelectionState::default();
            return;
        }

        if let Some(task_id) = self.selection.task_id.as_ref()
            && let Some(index) = self.visible_task_ids.iter().position(|id| id == task_id)
        {
            self.selection.visible_index = Some(index);
            return;
        }

        if let Some(visible_index) = self.selection.visible_index {
            let clamped = visible_index.min(self.visible_task_ids.len() - 1);
            self.selection.visible_index = Some(clamped);
            self.selection.task_id = Some(self.visible_task_ids[clamped].clone());
            return;
        }

        self.selection.visible_index = Some(0);
        self.selection.task_id = Some(self.visible_task_ids[0].clone());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn task(
        id: &str,
        name: &str,
        status: &str,
        created_at: i64,
        updated_at: i64,
    ) -> TaskListItem {
        TaskListItem {
            id: id.to_string(),
            name: name.to_string(),
            status: Some(status.to_string()),
            environment: Some("prod".to_string()),
            owner: Some("default".to_string()),
            created_at: Some(created_at),
            updated_at: Some(updated_at),
        }
    }

    #[test]
    fn refresh_request_starts_loading_cycle() {
        let mut state = TaskScreenState::new(10);
        let request = state.dispatch(TaskAction::RefreshRequested).expect("request must start");

        assert_eq!(
            request,
            TaskLoadRequest {
                request_id: 0,
                mode: TaskLoadMode::Refresh,
                cursor: None,
                page_size: 10,
                filters: TaskFilterState::default(),
            }
        );
        assert_eq!(
            state.fetch_state,
            TaskFetchState::Loading(TaskLoadInFlight {
                request_id: 0,
                mode: TaskLoadMode::Refresh,
                cursor: None
            })
        );
        assert!(state.needs_refetch);
    }

    #[test]
    fn refresh_success_replaces_items_and_selects_first_visible() {
        let mut state = TaskScreenState::new(5);
        let request = state.dispatch(TaskAction::RefreshRequested).expect("request");
        let response = TaskLoadResponse {
            items: vec![task("a", "Alpha", "running", 10, 11), task("b", "Beta", "completed", 20, 21)],
            next_cursor: Some("next".to_string()),
            has_more_hint: None,
        };

        state.dispatch(TaskAction::PageLoaded {
            request_id: request.request_id,
            response,
        });

        assert_eq!(state.fetch_state, TaskFetchState::Idle);
        assert_eq!(
            state.visible_task_ids,
            vec!["b".to_string(), "a".to_string()]
        );
        assert_eq!(state.selection.task_id, Some("b".to_string()));
        assert_eq!(state.pagination.next_cursor, Some("next".to_string()));
        assert!(state.pagination.has_more_hint);
    }

    #[test]
    fn append_success_appends_and_deduplicates_by_id() {
        let mut state = TaskScreenState::new(5);
        let first = state.dispatch(TaskAction::RefreshRequested).unwrap();
        state.dispatch(TaskAction::PageLoaded {
            request_id: first.request_id,
            response: TaskLoadResponse {
                items: vec![task("a", "Alpha", "running", 10, 11), task("b", "Beta", "completed", 20, 21)],
                next_cursor: Some("next".to_string()),
                has_more_hint: Some(true),
            },
        });

        let second = state.dispatch(TaskAction::NextPageRequested).unwrap();
        state.dispatch(TaskAction::PageLoaded {
            request_id: second.request_id,
            response: TaskLoadResponse {
                items: vec![task("b", "Beta-dup", "completed", 22, 23), task("c", "Gamma", "pending", 30, 31)],
                next_cursor: None,
                has_more_hint: None,
            },
        });

        let ids = state.items.iter().map(|item| item.id.as_str()).collect::<Vec<_>>();
        assert_eq!(ids, vec!["a", "b", "c"]);
        assert!(state.pagination.reached_end);
    }

    #[test]
    fn filter_changes_update_visibility_and_selection_stability() {
        let mut state = TaskScreenState::new(5);
        let request = state.dispatch(TaskAction::RefreshRequested).unwrap();
        state.dispatch(TaskAction::PageLoaded {
            request_id: request.request_id,
            response: TaskLoadResponse {
                items: vec![
                    task("a", "Alpha", "running", 10, 11),
                    task("b", "Beta", "completed", 20, 21),
                    task("c", "Gamma", "pending", 30, 31),
                ],
                next_cursor: None,
                has_more_hint: Some(false),
            },
        });

        state.dispatch(TaskAction::SetSelection(Some(1)));
        assert_eq!(state.selection.task_id, Some("a".to_string()));

        state.dispatch(TaskAction::SetQuery("bet".to_string()));
        assert_eq!(state.visible_task_ids, vec!["b".to_string()]);
        assert_eq!(state.selection.task_id, Some("b".to_string()));

        state.dispatch(TaskAction::SetStatusFilter(TaskStatusFilter::Running));
        assert_eq!(state.visible_task_ids.len(), 1);
        assert_eq!(state.visible_task_ids, vec!["a".to_string()]);
        assert_eq!(state.selection.task_id, Some("a".to_string()));
    }

    #[test]
    fn stale_response_is_ignored_until_active_request_matches() {
        let mut state = TaskScreenState::new(5);
        let request = state.dispatch(TaskAction::RefreshRequested).unwrap();
        let stale_request_id = request.request_id.saturating_add(10);

        state.dispatch(TaskAction::PageLoaded {
            request_id: stale_request_id,
            response: TaskLoadResponse {
                items: vec![task("stale", "Stale", "failed", 1, 1)],
                next_cursor: None,
                has_more_hint: None,
            },
        });

        assert!(state.fetch_state.is_loading());
        assert!(state.items.is_empty());

        state.dispatch(TaskAction::PageLoadFailed {
            request_id,
            error: "network".to_string(),
        });
        assert_eq!(state.error, Some("network".to_string()));
        assert!(matches!(state.fetch_state, TaskFetchState::Failed(_)));
    }
}
```


`codex-rs/tui/src/state/mod.rs` defines:
- async request lifecycle states/actions (`RefreshRequested`, `NextPageRequested`, `PageLoaded`, `PageLoadFailed`)
- selected task state and clamped selection behavior
- pagination placeholders (`TaskPaginationState`, cursor + end/hint flags)
- filter/search/sort state and placeholders (`TaskFilterState`, status/env/owner)
- reducer-style transitions via `TaskScreenState::dispatch`
